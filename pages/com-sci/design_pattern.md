---
제목 : 1.1 디자인 패턴
---


# 디자인 패턴이란?



디자인 패턴이란 프로그램을 설계할 때 자주 발생했던 문제점들을 해결 할 수 있도록 하나의 " 규약 " 형태로 정리한 약속입니다.  주로 시스템의 유지보수나 문서화 개선을 할 수 있으며 클래스의 명세 또한 정확하게 할 수 있도록 도와주는 역할을 합니다.이러한 디자인 패턴은 객체지향 소프트웨어에서 설계자가 재사용을 할 때 이용 가능한지 혹은 불가능한지 구분이 가능 할 수 있도록 도와줍니다.


디자인 패턴의 교과서라고 불리는 "GoF 디자인 패턴"에서는 객체 지향적 디자인 패턴을 "생성 패턴(Creational Pattern)", "구조 패턴(Structural Pattern)", "행동 패턴(Behavioral Pattern)" 총 23가지 디자인 패턴을 크게 3가지로 분류하고 있습니다.

![디자인-패턴](https://i.imgur.com/IYawu3X.png)

### 1. 생성(Creational) 패턴:

   생성 패턴은 객체를 생성하고 조합하는 방식을 다양하게 조정하여 유연성과 확장성을 높이는데 사용됩니다. 주요 생성 패턴으로는 다음과 같은 것들이 있습니다.

   - 싱글톤(Singleton): 클래스의 인스턴스를 하나로 제한하여 오직 하나의 객체만 생성되도록 한다.
   - 팩토리 메서드(Factory Method): 객체를 생성하는 인터페이스를 정의하고, 서브클래스가 어떤 클래스의 인스턴스를 생성할지 결정하도록 한다.
   - 추상 팩토리(Abstract Factory): 관련된 객체들의 그룹을 생성하기 위한 인터페이스를 제공하며, 서브클래스에서 이를 구현한다.
   - 빌더(Builder): 복잡한 객체의 생성 과정을 단계별로 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있도록 한다.
   - 프로토타입(Prototype): 기존 객체를 복제하여 새로운 객체를 생성하는 방법을 제공한다.



### 2. 구조(Structural) 패턴:

   구조 패턴은 클래스나 객체들을 조합하여 더 큰 구조를 형성하기 위한 패턴입니다. 이 패턴은 클래스들 간의 상호작용을 조율하고, 복잡한 구조를 간단하게 표현하기 위해 사용됩니다. 주요 구조 패턴으로는 다음과 같은 것들이 있습니다.

   - 어댑터(Adapter): 호환되지 않는 인터페이스를 가진 클래스들을 함께 동작하도록 변환시킨다.
   - 브리지(Bridge): 추상화와 구현을 분리하여 각각 독립적으로 변경할 수 있도록 한다.
   - 컴퍼지트(Composite): 개별 객체와 복합 객체를 동일하게 취급하여 클라이언트에게 투명하게 보이도록 한다.
   - 데코레이터(Decorator): 객체에 새로운 기능을 동적으로 추가하거나 기능을 제거할 수 있게 한다.
   - 퍼사드(Facade): 서브시스템들의 복잡한 인터페이스를 단순화시켜 클라이언트들이 사용하기 쉽게 만든다.
   - 플라이웨이트(Flyweight): 객체들 사이에 공유 가능한 정보를 효율적으로 공유하여 메모리를 절약한다.
   - 프록시(Proxy): 객체의 접근을 제어하기 위한 대리자를 제공한다.



### 3. 행위(Behavioral) 패턴:

   행위 패턴은 객체들 사이의 알고리즘 및 책임 분배와 관련된 문제를 해결하기 위한 패턴이다. 이 패턴은 객체들 간의 상호작용 방식을 정의하고, 효율적인 행위를 조정하는 데 사용됩니다. 주요 행위 패턴으로는 다음과 같은 것들이 있습니다:

   - 옵저버(Observer): 객체들 간의 일대다 의존 관계를 정의하여 한 객체의 상태 변경 시 다른 객체들에게 자동으로 알린다.
   - 스트래티지(Strategy): 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하여 서로 교환 가능하도록 한다.
   - 커맨드(Command): 요청을 객체의 형태로 캡슐화하여 요청에 대한 매개변수화, 메서드 호출, 연산을 지연시키거나 취소할 수 있게 한다.
   - 체인 오브 리스폰시빌리티(Chain of Responsibility): 요청을 처리하는 객체들을 체인 형태로 연결하여 요청을 처리할 객체를 동적으로 결정한다.
   - 인터프리터(Interpreter): 언어의 문법 규칙을 정의하고, 이를 해석하는 인터프리터를 구현하여 특정한 언어를 해석한다.
   - 이터레이터(Iterator): 컬렉션의 요소들에 접근하면서 순서를 보장하는 방법을 제공한다.
   - 미디에이터(Mediator): 객체들 간의 복잡한 상호작용을 캡슐화하여 중재자를 통해 객체들이 직접 통신하는 것을 방지한다.
   - 메멘토(Memento): 객체의 상태를 저장하고 이를 이후에 복원할 수 있도록 한다.
   - 스테이트(State): 객체의 내부 상태에 따라 동작을 변경하도록 한다.
   - 스트래티지(Strategy): 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하여 동적으로 교환 가능하게 한다.
   - 템플릿 메서드(Template Method): 알고리즘의 구조를 메서드에 정의하고, 하위 클래스에서 알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계들을 재정의할 수 있게 한다.
   - 비지터(Visitor): 객체 구조를 돌아다니며 특정한 연산을 수행할 수 있는 방문자를 구현한다.

이렇게 세 가지 주요 분류를 기준으로 디자인 패턴들은 개발자들이 자주 발생하는 문제를 더 쉽고 효율적으로 해결할 수 있도록 도와줍니다. 각 패턴은 특정한 상황에서 적합하며, 적절한 문제에 적절한 패턴을 적용하는 것이 중요합니다.

#디자인패턴
본 스터디에서 활용되는 [면접을 위한 CS 전공지식 노트 : 주홍철 ] 에서는 Gof 패턴으로 대표적으로 소개되는 것외로도 MVC패턴, MVP패턴(정확하게는 구조패턴에 포함이 된다)등을 포함하여 총 10가지 패턴에 대해 설명합니다. 이 패턴에 대해 조금더 심층적으로 알고자 하는 것에 목표를 두도록 합니다 ㅎㅎ. 






## 싱글톤 패턴 

싱글톤 패턴(singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다. 하나의 클래스를 기반으로 여러개의 개별적인 인스턴스를 만들 수 있지만 그렇게 하지 않고 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 로직을 만드는데 쓰인다.
이러한 싱글톤은 생성패턴 (Creational Patern)에 속하며 일반적으로 데이터 베이스 연결 모듈에 사용된다.  이렇게 하나의 인스턴스만을 생성하면 여러곳에서 해당 인스턴스를 공유하여 사용할 수 있어 메모리 낭비를 줄이고 일관된 데이터를 유지할 수 있다.

싱글톤 패턴을 구현하기 위해 다음과 같은 방법을 사용한다.

1) Private Constructor 
클래스 내부에 생산자(Constructor)를 privated로 선언하여 내부에서만 생성할 수 있게 만든다. 이는 외부에서 직접 인스턴스를 생성하는 것을 방지한다.

2) Static Method
클래스 내부에서 정적(static) 메서드를 정의하여 유일한 인스턴스를 반환하며 이 메서드는 항상 동일한 인스턴스를 반환하게 된다.

3) Static Variable
유일한 인스턴스를 저장하기 위해 클래스 내에 정적 변수( Static Variable)를 두고, 이 변수를 통해 인스턴스에 접근하게 된다. 


다만 이러한 싱클턴 패턴도 단점은 존재한다.

첫번째,  TDD(Test Driven Development)를 할 때 방해가 된다. TDD를 할 때 단위 테스트를 하는데 단위테스트는 테스트가 서로 독립적이어야하기 때문이다. 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 하기에 각자가 "독립적으로" 구성된 인스턴스를 활용하는 TDD에서는 활용하기 어렵다.

두번째, 모듈간의 결합을 매우 강하게 될 수도있다. 이는 다행히 "의존성 주입(DI,Dependency Injection)"을 통해 해결할 수 있기도 있다. 의존성 주입을 사용하면 모듈간의 결합이 좀 더 느슨해진다. 이렇게 메인모듈에 대한 하위모듈의 의존성을 떨어지게 함으로서 디터플링이 되도록 한다.
다만 이런 의존성 주입이 장점만 있는 것은 아니다. 모듈들이 더욱 더 분리되어 클래스 수가 늘어나 복잡성이 증가 될 수 있으며 약간의 런타임 패털티가 발생된다.
의존성 주입을 할 때 " 상위 모듈은 하위 모듈에서 어떤 것도 가져오지 않아야 한다, 또한 둘 다 추상화에 의존해야 하며 이때 추상화는 세부 사항에 의존하지 말아야 한다" 라는 의존성의 원칙을 꼭 상기시키면서 코드를 작성하도록 하자.


[디커플링]:
객체들과의 의존성을 최소화 할 수 있도록 설계 , 객체가 다른 객체를 직접 참고하지 않고 인터페이스에서 상호 작용 할 수 있도록 한다는 것이다.




## 팩토리 패턴 
팩토리 패턴(Factory pattern)은 구현(Implements)보다 인터페이스(Interface)를 위한 코드 접근법을 제공한다. 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다. 즉 객체 생성을 처리하는 방식을 추상화하여 클라이언트 코드와 구체적인 객체 생성 코드를 분리해 객체 생성의 유연성과 확장성을 제공하는 디자인 패턴 방법이다.
상위 클래스와 하위 클래스가 분리 되기 때문에 느슨한 결합을 가지며 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없어 더 많은 유연성을 갖게 된다. 그리고 객체 생성 로직이 따로 떼어져 있기에 코드를 리팩터링 하더라도 한곳만 고칠 수 있어 유지 보수성 또한 증가된다.


팩토리 패턴을 구현하기 위해서는 크게 두가지로 나눌 수 있다.

1) Simple Factory Pattern
단순 팩토리 패턴은 객체 생성을 하나의 팩토리 클래스에 모아두고, 클라이언트가 해당 팩토리 클래스를 사용하여 객체를 생성하는 방식이다.
구체적인 객체 생성 로직은 팩토리 클래스에 은닉되어 있으므로, 클라이언트는 생성되는 객체의 구체적인 클래스를 알 필요가 없다.

2) Factory Method Pattern
팩토리 메서드 패턴은 객체 생성을 하위 클래스로 분리하여 각 하위 클래스가 객체 생성을 담당하도록 하는 방식이다.
추상 팩토리 메서드를 선언하여 이를 하위 클래스들이 구현하도록 한다. 이를 통해 클라이언트는 객체를 생성할 때 하위 클래스를 직접 명시하지 않고도 객체를 생성할 수 있다.


팩토리 패턴 또한 이점만이 존재하지는 않는다. 

팩토리 패턴은 객체 생성을 책임지는 팩토리 클래스가 추가적으로 필요하기에 클래스 수가 증가하여 코드 복잡성이 증가 될 수 있어 객체 생성이 단순한 경우라면 팩토리 패턴을 도입하는 것이 오히려 더욱 복잡해질 수 있다.
또한 팩토리 패턴을 사용하면 클라이언트 코드는 팩토리 클래스와 함꼐 동작해야한다. 이로 인해 클라이언트 코드와 팩토리 클래스 사의의 의존성이 증가 될 수 있으며 팩토리 패턴을 사용해 다양한 종류의 객체를 생성해 여러 클래스에 생성로직이 중복되어 유지보수가 어려워 질 수 있다는 단점 또한 있으니 유의하도록 하자.


## 전략패턴

전략 패턴(strategy pattern)은 정책 패턴(policy pattern)이라고도 하며, 알고리즘을 정의하고 각각을 캡슐화해 상호교환 할 수 있도록 만드는 패턴이다. 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략으로 사용되는 캡슐화한 알고리즘을 컨텍스트 안에서 교체해주면서 상호교체가 가능하도록 만들어져 알고리즘의 변경이나 확장에 유연하게 사용 할 수 있다. 
전략 패턴의 예시는 삶에서도 쉽게 마주치는데 물건을 살때 결제가 되는 결제 방식 (페이코,카카오페이 등 )전략만 바꿔 구매하는 부분에서 발견할 수 있다.

이렇게 전략 패턴은 다음과 같은 상황에서 사용된다.

1. 여러 알고리즘 중 하나를 동적으로 선택해야 할 때
2. 알고리즘의 변화에 유연하게 대처해야 할 때
3. 상속을 통한 확장보다 인터페이스를 이용해 객체를 구성하는게 더 적합할 때

전략 패턴을 구현하기 위해서는 다음과 같은 세가지로 나눠진다.

1) Strategy Interface 
전략 패턴에서는 알고리즘을 추상화하는 인터페이스를 정의하여 여러 구체적인 알고리즘을 표준화해 교환 가능하도록 한다.
이러한 전략 인터페이스(Strategy Interface)는 일반적으로 추상 클래스 혹은 인터페이스로 구현된다.

2) Concrete Strategies
 전략 인터페이스(Strategy Interface)를 구현한 실제 알고리즘 클래스들이다. 각  구체적인 전략 클래스는 특정한 알고리즘을 실행하는 코드를 담고 있으며 클라이언트가 원하는 특정 알고리즘을 선택하여 사용할 때 이 중 하나의 구체적인 전략 클래스를 사용한다.

3) Context 
컨텍스트는 전략 패턴의 사용자인 클라이언트가 사용하는 인터페이스를 정의한다. 전략을 설정하고, 해당 전략을 사용하여 작업을 수행하는 역할을 하며 전략 인터페이스(Strategy Interface)를 참조하여 실제로 어떤 전략을 사용할지 결정한다.

전략패턴은 위와 같이 유연한 알고리즘 교체와 코드 재사용성을 향상시키고 인터페이스를 통한 결합도를 감소시키는 장점이 있지만 단점 또한 존재한다.
전략 패턴을 구현하며 각각의 전략은 별도의 클래스로 구현되기에 클래스 수가 증가하여 복잡성이 증가 할 수 있다. 또한 전략 패턴을 사용할 때마다 클라이언트가 직접 전략을 선택해야하여 큰라이언트의 코드가 복잡해질 수 있다. 이외에도 인터페이스를 통한 결합도를 감소시키는 만큼 적합한 인터페이스 설계가 필요한데 제대로 정의되지 않거나 변경이 잦아지는 경우 코드의 수정이 번거로워질 수 있다.

[컨텍스트] 
개발자가 작업을 완료하는데 필요한 모든 관련 정보 


## 옵저버 패턴

옵저버 패턴(observer pattern)은 객체들간의 일대다(one-to-many)의존성 관계를 정의하는 패턴이다. 옵저버 패턴을 사용하면 한 객체의 상태가 변경되었을 때, 의존하는 다른 객체들에게 자동으로 알림을 보내고 상태 변경에 대응할 수 있다. 주체가 어떤 객체(subject)의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 방식으로 진행된다.가장 대표적인 예로는 트위터로 주체가 포스팅을 올렸을때 팔로우에게 전달되는 방식이다 .
또한 옵저버 패턴은 구독등에도 활용되며 주로 이벤트 기반 시스템에 사용된다. MVC(Model-View-Controller)에도 이용된다.
설명하자면 모델에 변경 사항이 생겼을때 update() 메서드로 View에 안내가 가고 이를 기반으로 controller가 작동하는 것이다. 


옵저버 패턴은 다음과 같은 상황에서 사용된다.

1.한 객체의 상태 변경이 다른 여러 객체에게 영향을 미치는 때
2.상태 변경에 대해 클라이언트 코드가 명시적으로 알지 않아도 되는 때
3.상태 변경과 상관없이 다른 객체에게 데이터를 전달해야 하는 때


옵저버 패턴은 크게 두가지 주요 구성요소로 나눠진다.

1) Subject 
Subject는 상태를 관찰하고 있는 옵저버들의 목록을 관리한다.
Subject가 상태가 변경되었을 때, 등록된 옵저버들에게 알림을 보낸다.

2) Observer
Observer는 Subject의 상태 변경에 관심을 가지고, 상태 변경 시 알림을 받을 객체를 나타낸다.
Observer는 Subject에 등록되어 Subject로부터 알림을 받을 준비를 한다.

이러한 옵저버 패턴을 사용하면 느슨한 커플링(Loose Coupling)을 얻을 수 있다. Subject와 Observer들이 서로 독립적으로 동작해 Subject는 Observer의 구체적인 클래스를 알지 않아 객체간의 결합도가 낮아지고 유지보수와 확장성이 향상된다.또한 상태 변경에 대한 자동알림이 가능하며 새로운 옵저버를 추가하는 것이 간단해 확장성이 향상된다는게 장점이다.

하지만 단점으로는 크게 세가지가 있다. 
첫번째, Subject의 상태 변경에 대해 모든 Observer에게 알람을 보낸다는 것으로 불필요한 알람이 발생 할 수 있다는 것
두번째, 알람을 보내는 순서를 보장하기 어려워 추가적인 처리를 고려해야한다는 점
세번째, 메모리 누수의 가능성이 있단느 점, Observer들이 Subject에 등록된 상태에서 사용하지 않을 경우 메모리 누수가 발생할 수 있다. 또한 Subject에 등록된 옵저버가 제거되지 않고 계속 남아있는 경우 메모리 사용량이 증가 할 수 있다.
위와 같은 요구상황을 고려해 적절하게 설계하자.

## 프록시 패턴
프록시 패턴은 대상 객체(subject)에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴이다. 이를 통해 객체의 속성, 변화등을 보완하며 보안,데이터 검증, 캐싱 로깅에 사용한다.이는 앞서 설명한 프록시 객체로 쓰이기도 하지만 프록시 서버로도 활용된다.프록시는 실제 객체와 동일한 인터페이스를 갖고 있어 클라이언트가 프록시를 사용하는 데에는 실제 객체를 사용하는 것과 거의 동일하게 보인다. 사용 예시로는 원격 서버에 있는 파일을 다운로드 할때 프록시를 사용해 원격 파일에 접근하고 다운로드를 지연시키거나 불필요한 다운로드를 피할 수 있도록 할 수 있다. 

프록시 패턴을 사용하는 이유는 다음 3가지와 같다.

1. 접근 제어 : 실제 객체에 접근하는 것을 제어하고 프록시를 통해 간접접근을 하여 접근을 제어하고자 할 때 
2. 지연로딩 : 실제 객체가 비용이 많이 드는 작업을 수행하는 경우 해당 작업이 실제로 필요로 할 떄까지 지연하고자 할 때
3. 캐싱 : 프록시를 사용하여 실제 객체가 반환하는 결과를 캐싱 후 같은 요청에 대한 반복적인 연산을 피할 때


프록시 패턴은 다음과 같이 두가지 종류로 나눌 수 있다.


1) Virtual Proxy
 실제 객체의 생성이나 비용이 큰 작업을 지연시키기 위해 사용된다 클라이언트가 객체를 처음으로 요청할 때에만 실제 객체를 생성하고 초기화한다.

2) Remote Proxy
 실제 객체가 다른 주소 공간에 존재하는 경우 사용된다. 클라이언트는 마치 로컬에서 실행하는 것처럼 프록시를 통해 원격 객체에 접근할 수 있다.


이러한 프록시는 접근 제어,지연로딩,캐싱과 같은 장점이 있지만 단점 또한 존재한다.프록시를 통해 추가적인 로직이 수행되어 약간의 오버헤드가 발생해 지연로딩이나 캐싱을 구현할 때 두드러진다. 프록시는 위와 같이 성능과 유지보수성을 향상 시킬 수 있으나 복잡성과 오버헤드를 고려해 작성해야한다.


## 이터레이터 패턴


이터레이터 패턴(iterator pattern)은 컬렉션(collection)내부의 요소들을 순차적으로 접근하는 방법을 제공하는 패턴이다. 이터레이터(iterator)를 사용하여 컬렉션의 요소들에 사용할 수 있고 컬렉션의 내부구현과 사용방법을 분리하여 , 컬렉션의 구조가 변경되어도 사용자 코드에 영향을 최소화 한다는 이점이 있다. 

이터레이터의 특징은 다음과 같은 3가지로 구분할 수 있다.

1.외부 반복: 클라이언트가 이터레이터를 통해 요소에 직접 접근하고 제어할 때

2.컬렉션 내부 구조 감춤:클라이언트가 컬렉션의 내부 구현을 알 필요 없이 이터레이터를 통해 요소에 접근할 때

3.단일 책임 원칙: 컬렉션과 이터레이터는 각각의 책임을 분리하여 설계해 유지보수와 확장이 용이하고자 할 때


이터레이터의 구성요소는 다음과 같이 4가지이다. 

1) Iterator(인터페이스)
컬렉션 내부의 요소들을 순차적으로 접근하는 인터페이스를 정의한다.이터레이터는 컬렉션의 구체적인 구현과 독립적으로 동작하며 주로 hasNext() 메서드를 통해 다음 요소의 존재 여부를 확인하고, next() 메서드를 통해 다음 요소를 반환한다.

2) ConcreteIterator(클래스):
여러 요소들이 이루어져 있는 데이터 집합체로 Iterator 인터페이스를 구현하여 실제로 컬렉션의 요소를 접근하는 클래스이다.어떤 전략으로 순회할지에 대한 로직을 구체화하는 역할을 한다. 즉 실제 컬렉션의 내부 구현에 따라 이터레이터가 요소들을 순차적으로 접근하게 만든다.

3) Aggregate(인터페이스)
요소들을 포함하고 있는 컬렉션을 나타내는 인터페이스를 정의한다.주로 createIterator() 메서드를 통해 컬렉션에 대한 객체를 반환하는 인터페이스를 생성한다.

4) ConcreteAggregate(클래스)
여러 요소들이 이루어져있는 데이터 집합체로 Aggregate 인터페이스를 구현하여 실제로 요소들을 가지고 있는 컬렉션 클래스이다.createIterator() 메서드를 구현하여 구체적인 이터레이터를 생성하고 반환한다.


이터레이터 패턴을 사용하면 컬렉션의 구체적인 구현과 사용 방법이 분리되므로, 컬렉션의 내부 구조가 변경되어도 사용자 코드를 수정할 필요가 없어진다. 다양한 종류의 컬렉션에서 일관된 방법으로 요소들에 접근할 수 있게되어 코드의 재사용성과 유연성이 향상할 수 있게 된다. 다만 단점으로는 일부언어에서 이터레이터를 사용하는 것이 직접적으로 컬렉션으로 접근하는 것보다 약간의 성능적인 오버헤드가 발생할 수 있기에 이터레이터에 대한 효용성이 어떻게 되는지 알고 사용하는것이 좋다. 

## 노출 패턴

노출패턴은 즉시 실행 함수를 통해 private,public과 같은 접근제어자를 만드는 패턴이다.  객체지향 프로그래밍에서 객체의 내부상태를 직접 노출하는 것보다 캡슐화를 통해 외부로부터 접근을 제어한다. 이를 통해 객체 의 내부 구현 세부사항을 감추어 안정성과 유지보수성을 높일 수 있다.

노출 패턴의 핵심 원칙은 데이터 은닉과 캡슐화로 작성할 수 있다. 

\# 디자인패턴 \#생성패턴 \#구조패턴 \#행위패턴 \#싱글톤패턴 \#팩토리패턴 \#전략패턴 \#옵저버패턴 \#프록시패턴\#이터레이터패턴 \#노출패턴 \#GoF

