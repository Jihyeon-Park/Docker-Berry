---
제목 : 1.1 디자인 패턴
---


## 디자인 패턴이란?



디자인 패턴이란 프로그램을 설계할 때 자주 발생했던 문제점들을 해결 할 수 있도록 하나의 " 규약 " 형태로 정리한 약속입니다.  주로 시스템의 유지보수나 문서화 개선을 할 수 있으며 클래스의 명세 또한 정확하게 할 수 있도록 도와주는 역할을 합니다.이러한 디자인 패턴은 객체지향 소프트웨어에서 설계자가 재사용을 할 때 이용 가능한지 혹은 불가능한지 구분이 가능 할 수 있도록 도와줍니다.


디자인 패턴의 교과서라고 불리는 "GoF 디자인 패턴"에서는 객체 지향적 디자인 패턴을 "생성 패턴(Creational Pattern)", "구조 패턴(Structural Pattern)", "행동 패턴(Behavioral Pattern)" 총 23가지 디자인 패턴을 크게 3가지로 분류하고 있습니다.

![디자인-패턴](https://i.imgur.com/IqK0zhz.png)




### 1. 생성(Creational) 패턴:

   생성 패턴은 객체를 생성하고 조합하는 방식을 다양하게 조정하여 유연성과 확장성을 높이는데 사용됩니다. 주요 생성 패턴으로는 다음과 같은 것들이 있습니다.

   - 싱글톤(Singleton): 클래스의 인스턴스를 하나로 제한하여 오직 하나의 객체만 생성되도록 한다.
   - 팩토리 메서드(Factory Method): 객체를 생성하는 인터페이스를 정의하고, 서브클래스가 어떤 클래스의 인스턴스를 생성할지 결정하도록 한다.
   - 추상 팩토리(Abstract Factory): 관련된 객체들의 그룹을 생성하기 위한 인터페이스를 제공하며, 서브클래스에서 이를 구현한다.
   - 빌더(Builder): 복잡한 객체의 생성 과정을 단계별로 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있도록 한다.
   - 프로토타입(Prototype): 기존 객체를 복제하여 새로운 객체를 생성하는 방법을 제공한다.



### 2. 구조(Structural) 패턴:

   구조 패턴은 클래스나 객체들을 조합하여 더 큰 구조를 형성하기 위한 패턴입니다. 이 패턴은 클래스들 간의 상호작용을 조율하고, 복잡한 구조를 간단하게 표현하기 위해 사용됩니다. 주요 구조 패턴으로는 다음과 같은 것들이 있습니다.

   - 어댑터(Adapter): 호환되지 않는 인터페이스를 가진 클래스들을 함께 동작하도록 변환시킨다.
   - 브리지(Bridge): 추상화와 구현을 분리하여 각각 독립적으로 변경할 수 있도록 한다.
   - 컴퍼지트(Composite): 개별 객체와 복합 객체를 동일하게 취급하여 클라이언트에게 투명하게 보이도록 한다.
   - 데코레이터(Decorator): 객체에 새로운 기능을 동적으로 추가하거나 기능을 제거할 수 있게 한다.
   - 퍼사드(Facade): 서브시스템들의 복잡한 인터페이스를 단순화시켜 클라이언트들이 사용하기 쉽게 만든다.
   - 플라이웨이트(Flyweight): 객체들 사이에 공유 가능한 정보를 효율적으로 공유하여 메모리를 절약한다.
   - 프록시(Proxy): 객체의 접근을 제어하기 위한 대리자를 제공한다.



### 3. 행위(Behavioral) 패턴:

   행위 패턴은 객체들 사이의 알고리즘 및 책임 분배와 관련된 문제를 해결하기 위한 패턴이다. 이 패턴은 객체들 간의 상호작용 방식을 정의하고, 효율적인 행위를 조정하는 데 사용됩니다. 주요 행위 패턴으로는 다음과 같은 것들이 있습니다:

   - 옵저버(Observer): 객체들 간의 일대다 의존 관계를 정의하여 한 객체의 상태 변경 시 다른 객체들에게 자동으로 알린다.
   - 스트래티지(Strategy): 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하여 서로 교환 가능하도록 한다.
   - 커맨드(Command): 요청을 객체의 형태로 캡슐화하여 요청에 대한 매개변수화, 메서드 호출, 연산을 지연시키거나 취소할 수 있게 한다.
   - 체인 오브 리스폰시빌리티(Chain of Responsibility): 요청을 처리하는 객체들을 체인 형태로 연결하여 요청을 처리할 객체를 동적으로 결정한다.
   - 인터프리터(Interpreter): 언어의 문법 규칙을 정의하고, 이를 해석하는 인터프리터를 구현하여 특정한 언어를 해석한다.
   - 이터레이터(Iterator): 컬렉션의 요소들에 접근하면서 순서를 보장하는 방법을 제공한다.
   - 미디에이터(Mediator): 객체들 간의 복잡한 상호작용을 캡슐화하여 중재자를 통해 객체들이 직접 통신하는 것을 방지한다.
   - 메멘토(Memento): 객체의 상태를 저장하고 이를 이후에 복원할 수 있도록 한다.
   - 스테이트(State): 객체의 내부 상태에 따라 동작을 변경하도록 한다.
   - 스트래티지(Strategy): 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하여 동적으로 교환 가능하게 한다.
   - 템플릿 메서드(Template Method): 알고리즘의 구조를 메서드에 정의하고, 하위 클래스에서 알고리즘의 구조를 변경하지 않고 알고리즘의 특정 단계들을 재정의할 수 있게 한다.
   - 비지터(Visitor): 객체 구조를 돌아다니며 특정한 연산을 수행할 수 있는 방문자를 구현한다.

이렇게 세 가지 주요 분류를 기준으로 디자인 패턴들은 개발자들이 자주 발생하는 문제를 더 쉽고 효율적으로 해결할 수 있도록 도와줍니다. 각 패턴은 특정한 상황에서 적합하며, 적절한 문제에 적절한 패턴을 적용하는 것이 중요합니다.

본 스터디에서 활용되는 [면접을 위한 CS 전공지식 노트 : 주홍철 ] 에서는 Gof 패턴으로 대표적으로 소개되는 것외로도 MVC패턴, MVP패턴(정확하게는 구조패턴에 포함이 된다)등을 포함하여 총 10가지 패턴에 대해 설명합니다. 이 패턴에 대해 조금더 심층적으로 알고자 하는 것에 목표를 두도록 합니다 ㅎㅎ. 