---
title: 1.2 프로그래밍 패러다임

---

# 1.2 프로그래밍 패러다임

## 1.2.1 함수형 프로그래밍

* 선언형 프로그래밍은 무엇을 풀어내는가에 집중하는 패러다임이자, "프로그램은 함수로 이루어진 것이다."라는 명제가 담겨 있는 패러다임이다.
* 함수형 프로그래밍은 선언형 패러다임의 일종이며, 컴퓨터 프로그래밍 자체보다 먼저 등장했다.
* 알론소 처치가 수학 문제를 해결하는 과정에서 람다 계산법을 발명, 함수형 프로그래밍은 람다 계산법을 바탕으로 만들어졌다.
* 람다 계산법의 기초 개념은 불변성으로 심볼의 값이 변경되지 않는다는 것, 이는 할당문이 전혀 없다는 뜻
* 즉, 함수형 프로그래밍은 <u>할당문에 대해 규칙을 부과한다.</u>

함수형 프로그래밍은 프로세스보다 순수 함수에 집중해 문제를 해결하는 기법이다.<br> 프로세스에 집중하게 되면 여러 함수들이 사용하는 외부 변수가 바뀌어 예기치 못한 오류가 생기면 프로세스에 차질을 겪기 때문이다.

---

## 1.2.2 객체지향 프로그래밍

* 1966년 올레 요한 달, 크레스텐 니가드는 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오래 유지될 수 있음을 발견했다.
* 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 그리고 중첩 함수는 메소드가 된다.
* 함수 포인터를 특정 규칙에 따라 사용하는 과정을 통해 필연적으로 다형성이 등장하게 되었다.
* 즉, 객체 지향 프로그래밍은 <u>제어흐름의 간접적인 전환에 대해 규칙을 부과한다.</u>

객체지향 프로그래밍(OOP, Object-Oriented Programming)은 객체들의 집합으로 프로그램의 상호작용을 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말한다. 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느리다.
객체지향 프로그래밍은 추상화, 캡슐화, 상속성, 다형성을 기반으로 설명된다.
OO의 본질을 설명하기 위해 4가지에 기대기도 한다. 이들은 OO(Object-Oriented)가 이 네 가지 개념을 적절하게 조합한 것이거나, 최소한 4가지 요소를 반드시 지원해야 한다고 한다.
### 객체지향 프로그래밍의 특징
**추상화**<br>
추상화란 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.<br>
 추상화는 두 차원에서 일어난다.
 * 첫번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
 * 두번째 차원은은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.

 즉, 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이다.

<br>**캡슐화**<br>

* 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것을 말한다.
 이를 통해 데이터와 함수가 응집력있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 하지만 이는 OO가 아닌 언어에서도 충분히 가능하며, OO언어에서 오히려 깨진다.
* 실제로 많은 OO언어가 캡슐화를 강제하지 않으며, 단지 프로그래머가 캡슐화된 데이터를 우회해 사용하지 않을 거라는 믿음을 기반으로 한다.
<br>**상속성**<br>
* 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것을 말한다. 코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 중요하다. 하지만 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의 하는 일에 불과하다.
* OO언어가 고안되기 이전에 C를 이용해 상속과 비슷한 기법이 사용되었다. 다만, 상속만큼 편리한 방식은 절대 아니였고, 단일 상속 구현을 가능하나 다중 상속을 구현하기는 어려웠다.
* OO언어에서는 손수 할 필요없이 암묵적으로 업캐스팅(Upcasting)이 이루어져 편리한 방식을 제공하게 되었다.
<br>**다형성**<br>
* 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말한다.
* 다형성 역시 함수를 가리키는 포인터를 응용할 뿐, OO가 새롭게 만든 것은 전혀 없다. 하지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.
  * 만일, 프로그래머가 포인터를 통해 모든 함수를 호출하는 수동적인 관례를 지켜야 하는 사실을 망각하게 되면 버그가 발생한다. 이것은 찾아내고 없애기가 힘들다.
* OO언어는 이러한 관례를 없애줘 실수의 위험을 제거한다. = "제어흐름을 간접적으로 전환하는 규칙을 부과"한다고도 할 수 있다.
* OO의 등장으로 다형성을 손쉽게 사용할 수 있게 되면서 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

### 설계원칙
좋은 소프트웨어 시스템은 깔끔한 코드(clean code)로부터 시작한다.<br>
SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.
* 변경에 유연하다.
* 이해하기 쉽다.
* 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.<br>
 1. 단일 책임 원칙(SRP, Single Responsibility Principle)<br> 
  <u>하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임을 져야 한다</u>라는 원칙이다.<br>
  여기서 변경의 이유는 "하나의 액터(동일한 변경을 요청하는 한 명 이상의 사람들)"에 해당한다.<br>
  하나의 책임이라는 것은 모호하다.
    * 클 수 있고, 작을 수 있다.
    * 문맥과 상황에 따라 다르다.<br>
    중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것.<br>
 1. 개방-폐쇄 원칙(OCP, Open/Closed Principle)<br>
   소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.<br>
   인터페이스를 구현할 새로운 클래스를 하나 만들어서 새로운 기능을 구현<br>
   다형성을 활용하지만 OCP 원칙을 지키지 못하는 경우도 있다.<br> 
   -> 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.<br>
 2. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀
수 있어야 한다.<br>
  클래스는 상속이 되기 마련이고 부모, 자식이라는 계층 관계가 만들어진다. 즉, 범석 객체가 홍철 객체의 자식 계층일 때 범석 객체를 홍철 객체와 바뀌어도 문제가 없어야 한다.<br>
  다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위
한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.<br>
ex) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리
더라도 앞으로 가야함

 1. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)<br>
  하나의 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙이다.
  인터페이스가 명확해지고, 대체 가능성이 높아진다.
 1. 의존 역전 원칙(DIP, Dependency Inversion Principle)<br>
   자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙.<br>
   **역할에 의존하게 해야 한다.** 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워진다.
* 결론
  
  객체지향의 핵심은 다형성이다.<br>
  다형성만으로는 쉽게 부품을 갈아 끼우듯 개발할 수 없다.<br>
  다형성만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.<br>
  다형성만으로는 OCP, ICP를 지킬 수 없다.<br>

---

## 1.2.3 절차형(구조적) 프로그래밍

* 절차(Procedual)는 함수를 의미한다. 
* 절차형 프로그래밍은 반복될 가능성이 있는 모듈을 재사용 가능한 프로시저 단위(함수 단위)로 나눈 프로그래밍이다.
* 여기서 발전한 형태가 구조적 프로그래밍.
* 무분별한 점프(goto 문법)는 프로그램 구조에 해롭다 -> 대신 if/then/else와 do/while/until과 같은 더 익숙한 구조로 대체한다.
* 구조적 프로그래밍은 모듈을 기준으로 나뉜다.
* 즉, 절차적 프로그래밍이 프로시저로 쪼갰다면, 그 프로시저를 비슷한 애들끼리 묶어서 소스파일로 묶은 것을 모듈이라고 본다. 
* 절차형(구조적) 프로그래밍은 <u>제어흐름의 직접적인 전환에 대해 규칙을 부과</u>한다.

일이 진행되는 순서대로 프로그래밍하는 방법으로 프로그램 전체가 유기적으로 연결되어 있다. 절차지향 프로그래밍은 코드가 분리되어 있으면 동작하지 않으며, 순서를 지키지 않으면 다른 결과가 나타날 수 있다.


### **생각할 거리**
* 각 패러다임은 프로그래머에게 권한을 박탈한다.
* 어느 패러다임도 새로운 권한을 부여하지 않고 부정적인 의도를 갖는 일종의 패널티를 부과한다.
* 패러다임은 무엇을 해야 할 지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.
  

>참조<br>
https://kamang-it.tistory.com/3 [프로그래밍 패러다임]순차적(비구조적),절차적(구조적),객체지향적 프로그래밍 <br>
https://www.yes24.com/Product/Goods/77283734 클린 아키텍처 <br>
https://www.yes24.com/Product/Goods/18249021 객체지향의 사실과 오해 <br>
https://hymndev.tistory.com/76 절차지향, 객체지향, 함수형 프로그래밍 <br>
https://www.youtube.com/watch?v=jVG5jvOzu9Y&t=453s 함수형 프로그래밍이 뭔가요? <br>